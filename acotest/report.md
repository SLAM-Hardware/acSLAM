# 协程
## 关键问题：在SLAM后端g2o库里面，到底各个线程是怎么一个执行情况？只有先找到优化点，才能对症下药
## 定义
协程（Coroutine）是一种轻量级的用户态线程，实现的是非抢占式的调度，即由当前协程切换到其他协程由当前协程来控制。目前的协程框架一般都是设计成 1:N 模式。所谓 1:N 就是一个线程作为一个容器里面放置多个协程。那么谁来适时的切换这些协程？答案是有协程自己主动让出 CPU，也就是每个协程池里面有一个调度器，这个调度器是被动调度的。意思就是他不会主动调度。而且当一个协程发现自己执行不下去了（比如异步等待网络的数据回来，但是当前还没有数据到)，这个时候就可以由这个协程通知调度器，这个时候执行到调度器的代码，调度器根据事先设计好的调度算法找到当前最需要 CPU 的协程。切换这个协程的 CPU 上下文把 CPU 的运行权交个这个协程，直到这个协程出现执行不下去需要等等的情况，或者它调用主动让出 CPU 的 API 之类，触发下一次调度。
## 没有银弹：只能串行
协程不是进程，也不是线程，它就是一个函数，一个特殊的函数——可以在某个地方挂起，并且可以重新在挂起处继续运行。所以说，协程与进程、线程相比，不是一个维度的概念。

一个进程可以包含多个线程，一个线程也可以包含多个协程，也就是说，一个线程内可以有多个那样的特殊函数在运行。但是有一点，必须明确，一个线程内的多个协程的运行是串行的。如果有多核CPU的话，多个进程或一个进程内的多个线程是可以并行运行的，但是一个线程内的多个协程却绝对串行的，无论有多少个CPU（核）。这个比较好理解，毕竟协程虽然是一个特殊的函数，但仍然是一个函数。一个线程内可以运行多个函数，但是这些函数都是串行运行的。当一个协程运行时，其他协程必须挂起。

因此，大多数库都将多线程和多协程结合起来，比如PHP的swoole和Python的gevent

![对比](https://img-blog.csdn.net/20180604212019658)

## 优点

1. 协程更加轻量，创建成本更小，降低了内存消耗。协程本身可以做在用户态，每个协程的体积比线程要小得多，因此一个进程可以容纳数量相当可观的协程

2. 协作式的用户态调度器，减少了 CPU 上下文切换的开销，提高了 CPU 缓存命中率。协作式调度相比抢占式调度的优势在于上下文切换开销更少、更容易把缓存跑热。和多线程比，线程数量越多，协程的性能优势就越明显。进程 / 线程的切换需要在内核完成，而协程不需要，协程通过用户态栈实现，更加轻量，速度更快。在重 I/O 的程序里有很大的优势。比如爬虫里，开几百个线程会明显拖慢速度，但是开协程不会。

3. 但协程也放弃了原生线程的优先级概念，如果存在一个较长时间的计算任务，由于内核调度器总是优先 IO 任务，使之尽快得到响应，就将影响到 IO 任务的响应延时。假设这个线程中有一个协程是 CPU 密集型的他没有 IO 操作，也就是自己不会主动触发调度器调度的过程，那么就会出现其他协程得不到执行的情况，所以这种情况下需要程序员自己避免。

4. 此外，单线程的协程方案并不能从根本上避免阻塞，比如文件操作、内存缺页，这都属于影响到延时的因素。

5. 减少同步加锁，整体上提高了性能

6. 协程方案基于事件循环方案，减少了同步加锁的频率。但若存在竞争，并不能保证临界区，因此该上锁的地方仍需要加上协程锁。可以按照同步思维写异步代码，即用同步的逻辑，写由协程调度的回调。需要注意的是，协程的确可以减少 callback 的使用但是不能完全替换 callback。基于事件驱动的编程里面反而不能发挥协程的作用而用 callback 更适合。

## 缺点

1. 在协程执行中不能有阻塞操作，否则整个线程被阻塞(协程是语言级别的，线程，进程属于操作系统级别)

2. 需要特别关注全局变量、对象引用的使用

3. 协程可以处理 IO 密集型程序的效率问题，但是处理 CPU 密集型不是它的长处。
假设这个线程中有一个协程是 CPU 密集型的他没有 IO 操作，也就是自己不会主动触发调度器调度的过程，那么就会出现其他协程得不到执行的情况，所以这种情况下需要程序员自己避免。

## 适用场景

一个线程内的多个协程是串行执行的，不能利用多核，所以，显然，协程不适合计算密集型的场景。协程适合I/O 阻塞型。

### 高性能计算，牺牲公平性换取吞吐。

协程最早来自高性能计算领域的成功案例，协作式调度相比抢占式调度而言，可以在牺牲公平性时换取吞吐。

### IO Bound 的任务

在 IO 密集型的程序中由于 IO 操作远远小于 CPU 的操作，所以往往需要 CPU 去等 IO 操作。同步 IO 下系统需要切换线程，让操作系统可以再 IO 过程中执行其他的东西。这样虽然代码是符合人类的思维习惯但是由于大量的线程切换带来了大量的性能的浪费。

所以人们发明了异步 IO。就是当数据到达的时候触发我的回调。来减少线程切换带来性能损失。但是这样的坏处也是很大的，最大的问题就是破坏掉了人类这种线性的思维模式，你必须把一个逻辑上线性的过程切分成若干个片段，每个片段的起点和终点就是异步事件的完成和开始。固然经过一些训练你可以适应这种思维模式，但你还是要付出额外的心智负担。与人类的思维模式相对应，大多数流行的编程语言都是命令式的，程序本身呈现出一个大致的线性结构。异步回调在破坏点思维连贯性的同时也破坏掉了程序的连贯性，让你在阅读程序的时候花费更多的精力。这些因素对于一个软件项目来说都是额外的维护成本，所以大多数公司并不是很青睐 node.js 或者 RxJava 之类的异步回调框架，尽管这些框架能提升程序的并发能力。

但是协程可以很好解决这个问题。比如把一个 IO 操作 写成一个协程。当触发 IO 操作的时候就自动让出 CPU 给其他协程。要知道协程的切换很轻的。协程通过这种对异步 IO 的封装既保留了性能也保证了代码的容易编写和可读性。

### Generator 式的流式计算

消除 Callback Hell（回调地狱），使用同步模型降低开发成本的同时保留更灵活控制流的好处，比如同时发三个请求；这时节约地使用栈，可以充分地发挥 "轻量" 的优势。

## 现有协程实现（C/C++）

### C++20官方提出了[协程支持](https://zh.cppreference.com/w/cpp/language/coroutines)，但是只有一个框架，到C++23才有完整的语言级支持

### 但是，基于这个标准的库（比如[cppcro](https://github.com/lewissbaker/cppcoro)，[coroutine](https://github.com/luncliff/coroutine)）都比较笨重，而且需要非常熟悉 C++17/20 新特性

### 还有一些基于 golang 的[c++库](https://github.com/idealvin/co)，但是私货太多

### 还有glibc里面的ucontext，不过那个太裸了，是提供给用户自己实现协程库的工具

### libaco 作为工业级的协程库（微信团队用的libco受它启发）只有 700 多行C代码，性能很不错

### 除此之外，还有[google的promises](https://github.com/google/promises)和[阿里巴巴的coobjc](https://github.com/alibaba/coobjc/blob/master/README_cn.md)，但他们都是面向iOS端的。

## libaco
原理及使用见[libaco文档](./libaco-master/README_zh.md)